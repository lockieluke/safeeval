#!/usr/bin/env bun
import { addCleanupListener } from "async-cleanup";
import { $ } from "bun";
import chalk from "chalk";
import * as fs from "fs-extra";
import isUrl from "is-url";
import * as path from "path";
import { parseArgs } from "util";
import yoctoSpinner from "yocto-spinner";
import { analyseScriptActions, analyseScriptRisks } from "./lib/analysis";
import { fetchScript } from "./lib/networking";
import { isPlatformSupported, isSudo } from "./lib/platform";
import { renderAnalysis } from "./lib/rendering";

const { positionals, values } = parseArgs({
  args: Bun.argv,
  options: {
    "skip-analysis": {
      type: "boolean"
    }
  },
  allowPositionals: true
});

if (!isPlatformSupported)
  throw new Error("safeeval is only supportde on macOS and Linux");

const [, , url] = positionals;
if (!url || !isUrl(url))
  throw new Error("Please provide a valid URL as the first argument.");

let spinner = yoctoSpinner({
  text: "Initialising environment"
}).start();

const tempdir = await fs.mkdtemp("safeeval");

const cleanup = async (exitCode: number = Number.MIN_SAFE_INTEGER) => {
  if (await fs.exists(tempdir))
    await fs.rmdir(tempdir, { recursive: true });

  if (exitCode !== Number.MIN_SAFE_INTEGER)
    process.exit(exitCode);
}

addCleanupListener(cleanup);
process.once("beforeExit", cleanup);
process.once("exit", cleanup);

spinner.success("Environment initialised");
spinner = yoctoSpinner({
  text: "Fetching script"
}).start();

const script = await fetchScript(url);
const scriptPath = path.join(tempdir, "script.sh");

await fs.writeFile(scriptPath, script);
const fileType = await $`/usr/bin/file --mime -b ${scriptPath}`.nothrow().quiet().text();
if (!fileType.startsWith("text/x-shellscript")) {
  spinner.error("The fetched file is not a valid shell script.");
  process.exit(1);
}

spinner.success("Downloaded script");

if (!values["skip-analysis"]) {
  if (!process.env.OPENROUTER_API_KEY && !process.env.OPENROUTER_API_BASE) {
    console.error(chalk.red("Error: OPENROUTER_API_KEY or OPENROUTER_API_BASE environment variable is not set. Security analysis cannot be performed without it."));
    await cleanup(1);
  }

  spinner = yoctoSpinner({
    text: "Analysing script"
  }).start();

  const [{ analysis, title, model: analysisModel }, { riskAnalysis, model: riskAnalysisModel }] = await Promise.all([
    analyseScriptActions(script),
    analyseScriptRisks(script)
  ]);

  spinner.success("Analysed script");

  console.log(`\n${chalk.bgGray(chalk.bold(title))}`);

  console.log(chalk.bold("\nðŸ’ª Identified Actions"));
  console.log(renderAnalysis(analysis));
  console.log(chalk.gray(`Generated by ${analysisModel}`));

  console.log(chalk.red(chalk.bold("\nðŸš¨ Identified Risks")));
  console.log(renderAnalysis(riskAnalysis));
  console.log(chalk.gray(`Generated by ${riskAnalysisModel}`));
}

const wantsToExecute = prompt(`\nDo you want to run this script${isSudo ? ` ${chalk.bold("as a SUPERUSER")}` : ""}(N/y)?`);
if (!wantsToExecute)
  await cleanup(0);

if (!["y", "n", "yes", "no"].includes(wantsToExecute!.trim().toLowerCase()) || wantsToExecute!.trim().toLowerCase().startsWith("n"))
  await cleanup(0);

const proc = Bun.spawn(["/bin/bash", path.resolve(tempdir, path.basename(scriptPath))], {
  stdin: "inherit",
  stdout: "inherit",
  stderr: "inherit",
  cwd: tempdir,
  env: process.env
});

console.log(chalk.italic(chalk.gray(`Running script from ${url}`)));

const exitCode = await proc.exited;
if (exitCode !== 0) {
  console.error(chalk.red(`\nScript exited with code ${exitCode}`));
  cleanup(exitCode);
}

cleanup();
